---
layout: post
title: CS:APP Bomb Lab
date: 2017-02-10 09:00:00
updated: 2017-02-10 23:42:00
tags: ["CS:APP", "assembly"]
---




本文记录了学习 CS:APP 3e Bomb Lab 的过程，断断续续干了两天。

所使用的版本发布日期为 Tuesday, January 12, 2016 （见 下载地址：[Lab Assignments](http://csapp.cs.cmu.edu/3e/labs.html) ，更新说明： [Updated the CS:APP Bomb Lab](http://csappbook.blogspot.com/2016/01/updated-csapp-bomb-lab.html)）

<!-- more -->

## 工具

* objdump

  * `objdump -t ./bomb` 查看符号表
  * `objdump -d ./bomb > ./bomb.asm ` 导出汇编代码进行反汇编
  * `objdump -s -j .rodata ./bomb` 查看`.rodata section`
  * `objdump -s -j .data ./bomb` 查看`.data section`

* GDB

  原本想只靠 objdump 进行静态分析的，结果到隐藏关卡还是觉着用 GDB 方便些 >_<

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
```

## phase_1

```assembly
  # void phase_1(char *input)
  0000000000400ee0 <phase_1>:
  400ee0:       48 83 ec 08             sub    $0x8,%rsp
  400ee4:       be 00 24 40 00          mov    $0x402400,%esi
                                        # 查 .rodata section 得知为字符串:
                                        # "Border relations with Canada have never been better."
  400ee9:       e8 4a 04 00 00          callq  401338 <strings_not_equal>
  400eee:       85 c0                   test   %eax,%eax
  400ef0:       74 05                   je     400ef7 <phase_1+0x17>
  400ef2:       e8 43 05 00 00          callq  40143a <explode_bomb>
  400ef7:       48 83 c4 08             add    $0x8,%rsp
  400efb:       c3                      retq	
```

```
# 导出 .rodata section
# objdump -s -j .rodata ./bomb

./bomb:     file format elf64-x86-64

Contents of section .rodata:
 4022b0 01000200 72002573 3a204572 726f723a  ....r.%s: Error:
 4022c0 20436f75 6c646e27 74206f70 656e2025   Couldn't open %
 4022d0 730a0055 73616765 3a202573 205b3c69  s..Usage: %s [<i
 4022e0 6e707574 5f66696c 653e5d0a 00546861  nput_file>]..Tha
 4022f0 74277320 6e756d62 65722032 2e20204b  t's number 2.  K
 402300 65657020 676f696e 67210048 616c6677  eep going!.Halfw
 402310 61792074 68657265 2100476f 6f642077  ay there!.Good w
 402320 6f726b21 20204f6e 20746f20 74686520  ork!  On to the
 402330 6e657874 2e2e2e00 57656c63 6f6d6520  next....Welcome
 402340 746f206d 79206669 656e6469 7368206c  to my fiendish l
 402350 6974746c 6520626f 6d622e20 596f7520  ittle bomb. You
 402360 68617665 20362070 68617365 73207769  have 6 phases wi
 402370 74680000 00000000 77686963 6820746f  th......which to
 402380 20626c6f 7720796f 75727365 6c662075   blow yourself u
 402390 702e2048 61766520 61206e69 63652064  p. Have a nice d
 4023a0 61792100 00000000 50686173 65203120  ay!.....Phase 1
 4023b0 64656675 7365642e 20486f77 2061626f  defused. How abo
 4023c0 75742074 6865206e 65787420 6f6e653f  ut the next one?
 4023d0 00000000 00000000 536f2079 6f752067  ........So you g
 4023e0 6f742074 68617420 6f6e652e 20205472  ot that one.  Tr
 4023f0 79207468 6973206f 6e652e00 00000000  y this one......
 402400 426f7264 65722072 656c6174 696f6e73  Border relations
 402410 20776974 68204361 6e616461 20686176   with Canada hav
 402420 65206e65 76657220 6265656e 20626574  e never been bet
 402430 7465722e 00000000 576f7721 20596f75  ter.....Wow! You
 402440 27766520 64656675 73656420 74686520  've defused the
 402450 73656372 65742073 74616765 2100666c  secret stage!.fl
 402460 79657273 00000000 00000000 00000000  yers............
 402470 7c0f4000 00000000 b90f4000 00000000  |.@.......@.....
 402480 830f4000 00000000 8a0f4000 00000000  ..@.......@.....
 402490 910f4000 00000000 980f4000 00000000  ..@.......@.....
 4024a0 9f0f4000 00000000 a60f4000 00000000  ..@.......@.....
 4024b0 6d616475 69657273 6e666f74 7662796c  maduiersnfotvbyl
 4024c0 536f2079 6f752074 68696e6b 20796f75  So you think you
 4024d0 2063616e 2073746f 70207468 6520626f   can stop the bo
 4024e0 6d622077 69746820 6374726c 2d632c20  mb with ctrl-c,
 4024f0 646f2079 6f753f00 43757273 65732c20  do you?.Curses,
 402500 796f7527 76652066 6f756e64 20746865  you've found the
 402510 20736563 72657420 70686173 65210000   secret phase!..
 402520 42757420 66696e64 696e6720 69742061  But finding it a
 402530 6e642073 6f6c7669 6e672069 74206172  nd solving it ar
 402540 65207175 69746520 64696666 6572656e  e quite differen
 402550 742e2e2e 00000000 436f6e67 72617475  t.......Congratu
 402560 6c617469 6f6e7321 20596f75 27766520  lations! You've
 402570 64656675 73656420 74686520 626f6d62  defused the bomb
 402580 21005765 6c6c2e2e 2e004f4b 2e203a2d  !.Well....OK. :-
 402590 2900496e 76616c69 64207068 61736525  ).Invalid phase%
 4025a0 730a000a 424f4f4d 21212100 54686520  s...BOOM!!!.The
 4025b0 626f6d62 20686173 20626c6f 776e2075  bomb has blown u
 4025c0 702e0025 64202564 20256420 25642025  p..%d %d %d %d %
 4025d0 64202564 00457272 6f723a20 5072656d  d %d.Error: Prem
 4025e0 61747572 6520454f 46206f6e 20737464  ature EOF on std
 4025f0 696e0047 52414445 5f424f4d 42004572  in.GRADE_BOMB.Er
 402600 726f723a 20496e70 7574206c 696e6520  ror: Input line
 402610 746f6f20 6c6f6e67 00256420 25642025  too long.%d %d %
 402620 73004472 4576696c 00677265 61747768  s.DrEvil.greatwh
 402630 6974652e 6963732e 63732e63 6d752e65  ite.ics.cs.cmu.e
 402640 64750061 6e67656c 73686172 6b2e6963  du.angelshark.ic
 402650 732e6373 2e636d75 2e656475 006d616b  s.cs.cmu.edu.mak
 402660 6f736861 726b2e69 63732e63 732e636d  oshark.ics.cs.cm
 402670 752e6564 75000000 50726f67 72616d20  u.edu...Program
 402680 74696d65 64206f75 74206166 74657220  timed out after
 402690 25642073 65636f6e 64730a00 00000000  %d seconds......
 4026a0 4572726f 723a2048 54545020 72657175  Error: HTTP requ
 4026b0 65737420 6661696c 65642077 69746820  est failed with
 4026c0 6572726f 72202564 3a202573 00000000  error %d: %s....
 4026d0 47455420 2f25732f 7375626d 6974722e  GET /%s/submitr.
 4026e0 706c2f3f 75736572 69643d25 73266c61  pl/?userid=%s&la
 4026f0 623d2573 26726573 756c743d 25732673  b=%s&result=%s&s
 402700 75626d69 743d7375 626d6974 20485454  ubmit=submit HTT
 402710 502f312e 300d0a0d 0a000000 00000000  P/1.0...........
 402720 4572726f 723a2055 6e61626c 6520746f  Error: Unable to
 402730 20636f6e 6e656374 20746f20 73657276   connect to serv
 402740 65722025 73000000 25252530 32580025  er %s...%%%02X.%
 402750 73202564 20255b61 2d7a412d 7a205d00  s %d %[a-zA-z ].
 402760 6368616e 67656d65 2e696373 2e63732e  changeme.ics.cs.
 402770 636d752e 65647500 0a415554 4f524553  cmu.edu..AUTORES
 402780 554c545f 53545249 4e473d25 730a0063  ULT_STRING=%s..c
 402790 73617070 00                          sapp.
```

这个很容易就能得到答案： `Border relations with Canada have never been better.`


```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
```

## phase_2
```assembly
# void phase_2(char *input);
0000000000400efc <phase_2>:
  400efc:       55                      push   %rbp
  400efd:       53                      push   %rbx
  400efe:       48 83 ec 28             sub    $0x28,%rsp
  400f02:       48 89 e6                mov    %rsp,%rsi  # numbers[6]
  400f05:       e8 52 05 00 00          callq  40145c <read_six_numbers>
                                        # read_six_numbers(input, numbers);
  400f0a:       83 3c 24 01             cmpl   $0x1,(%rsp)           # numbers[0] == 1
  400f0e:       74 20                   je     400f30 <phase_2+0x34>
  400f10:       e8 25 05 00 00          callq  40143a <explode_bomb>
  400f15:       eb 19                   jmp    400f30 <phase_2+0x34>
  400f17:       8b 43 fc                mov    -0x4(%rbx),%eax       # numbers[i-1]
  400f1a:       01 c0                   add    %eax,%eax             # numbers[i-1] * 2
  400f1c:       39 03                   cmp    %eax,(%rbx)
                                        # compare numbers[i-1] * 2 and numbers[i]
  400f1e:       74 05                   je     400f25 <phase_2+0x29>
  400f20:       e8 15 05 00 00          callq  40143a <explode_bomb>
  400f25:       48 83 c3 04             add    $0x4,%rbx             # get &numbers[++i]
  400f29:       48 39 eb                cmp    %rbp,%rbx             # compare i and 6
  400f2c:       75 e9                   jne    400f17 <phase_2+0x1b>
  400f2e:       eb 0c                   jmp    400f3c <phase_2+0x40>
  400f30:       48 8d 5c 24 04          lea    0x4(%rsp),%rbx         # get &numbers[i], i = 1
  400f35:       48 8d 6c 24 18          lea    0x18(%rsp),%rbp        # &numbers[6]
  400f3a:       eb db                   jmp    400f17 <phase_2+0x1b>
  400f3c:       48 83 c4 28             add    $0x28,%rsp
  400f40:       5b                      pop    %rbx
  400f41:       5d                      pop    %rbp
  400f42:       c3                      retq
```

```assembly
# void read_six_numbers(char *input, int *numbers);
# int sscanf( const char *restrict buffer, const char *restrict format, ... );
000000000040145c <read_six_numbers>:
  40145c:       48 83 ec 18             sub    $0x18,%rsp
  401460:       48 89 f2                mov    %rsi,%rdx             # &number[0]
  401463:       48 8d 4e 04             lea    0x4(%rsi),%rcx        # &number[1]
  401467:       48 8d 46 14             lea    0x14(%rsi),%rax
  40146b:       48 89 44 24 08          mov    %rax,0x8(%rsp)        # &number[5]
  401470:       48 8d 46 10             lea    0x10(%rsi),%rax
  401474:       48 89 04 24             mov    %rax,(%rsp)           # &number[4]
  401478:       4c 8d 4e 0c             lea    0xc(%rsi),%r9         # &number[3]
  40147c:       4c 8d 46 08             lea    0x8(%rsi),%r8         # &number[2]
  401480:       be c3 25 40 00          mov    $0x4025c3,%esi        # format = "%d %d %d %d %d %d"
  401485:       b8 00 00 00 00          mov    $0x0,%eax
  40148a:       e8 61 f7 ff ff          callq  400bf0 <__isoc99_sscanf@plt>
  40148f:       83 f8 05                cmp    $0x5,%eax
  401492:       7f 05                   jg     401499 <read_six_numbers+0x3d>
  401494:       e8 a1 ff ff ff          callq  40143a <explode_bomb>
  401499:       48 83 c4 18             add    $0x18,%rsp
  40149d:       c3                      retq
```

这个也很容易，答案： `1 2 4 8 16 32`

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
```

## phase_3
```assembly
# void phase_3(char *input)
0000000000400f43 <phase_3>:
  400f43:       48 83 ec 18             sub    $0x18,%rsp
  400f47:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx           # &number1
  400f4c:       48 8d 54 24 08          lea    0x8(%rsp),%rdx           # &number0
  400f51:       be cf 25 40 00          mov    $0x4025cf,%esi           # format = "%d %d"
  400f56:       b8 00 00 00 00          mov    $0x0,%eax
  400f5b:       e8 90 fc ff ff          callq  400bf0 <__isoc99_sscanf@plt>
  400f60:       83 f8 01                cmp    $0x1,%eax
  400f63:       7f 05                   jg     400f6a <phase_3+0x27>
  400f65:       e8 d0 04 00 00          callq  40143a <explode_bomb>
  # switch(number0) {
  400f6a:       83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)           # compare number0 and 7
  400f6f:       77 3c                   ja     400fad <phase_3+0x6a>    # if >, BOOM!
  400f71:       8b 44 24 08             mov    0x8(%rsp),%eax           # get number0
  400f75:       ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)       # goto table[number0]
  
      # 402470 7c0f4000 00000000 b90f4000 00000000  |.@.......@.....
      # 402480 830f4000 00000000 8a0f4000 00000000  ..@.......@.....
      # 402490 910f4000 00000000 980f4000 00000000  ..@.......@.....
      # 4024a0 9f0f4000 00000000 a60f4000 00000000  ..@.......@.....
      # long table[] = { 0x00400f7c, 0x00400fb9, 0x00400f83, 0x00400f8a, 
      #                  0x00400f91, 0x00400f98, 0x00400f9f, 0x00400fa6 };

  #   case 0:
  400f7c:       b8 cf 00 00 00          mov    $0xcf,%eax
  #   value = 0xcf;
  400f81:       eb 3b                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 2:
  400f83:       b8 c3 02 00 00          mov    $0x2c3,%eax
  #   value = 0x2c3;
  400f88:       eb 34                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 3:
  400f8a:       b8 00 01 00 00          mov    $0x100,%eax
  #   value = 0x100;
  400f8f:       eb 2d                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 4:
  400f91:       b8 85 01 00 00          mov    $0x185,%eax
  #   value = 0x185;
  400f96:       eb 26                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 5:
  400f98:       b8 ce 00 00 00          mov    $0xce,%eax
  #   value = 0xce;
  400f9d:       eb 1f                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 6:
  400f9f:       b8 aa 02 00 00          mov    $0x2aa,%eax
  #   value = 0x2aa;
  400fa4:       eb 18                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   case 7:
  400fa6:       b8 47 01 00 00          mov    $0x147,%eax
  #   value = 0x147;
  400fab:       eb 11                   jmp    400fbe <phase_3+0x7b>
  #   break;
  #   default:
  400fad:       e8 88 04 00 00          callq  40143a <explode_bomb>
  400fb2:       b8 00 00 00 00          mov    $0x0,%eax
  400fb7:       eb 05                   jmp    400fbe <phase_3+0x7b>
  #    break:
  #    case 1:
  400fb9:       b8 37 01 00 00          mov    $0x137,%eax
  #   value = 0x137;
  # }
  400fbe:       3b 44 24 0c             cmp    0xc(%rsp),%eax        # compare number1 and value
  400fc2:       74 05                   je     400fc9 <phase_3+0x86>
  400fc4:       e8 71 04 00 00          callq  40143a <explode_bomb>
  400fc9:       48 83 c4 18             add    $0x18,%rsp
  400fcd:       c3                      retq
```

可能的答案为：

* 0 207
* 1 311
* 2 707
* 3 256
* 4 389
* 5 206
* 6 682
* 7 327

~~注意到这里使用了寄存器 `%eax`，因此此函数可能返回了相应的value值~~（事后证明这里想多了）。

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
```

## phase_4

```assembly
# void phase_4(char *input)
000000000040100c <phase_4>:
  40100c:       48 83 ec 18             sub    $0x18,%rsp
  401010:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx		     # get &number1
  401015:       48 8d 54 24 08          lea    0x8(%rsp),%rdx            # get &number0
  40101a:       be cf 25 40 00          mov    $0x4025cf,%esi            # format = "%d %d"
  40101f:       b8 00 00 00 00          mov    $0x0,%eax
  401024:       e8 c7 fb ff ff          callq  400bf0 <__isoc99_sscanf@plt>
  401029:       83 f8 02                cmp    $0x2,%eax
  40102c:       75 07                   jne    401035 <phase_4+0x29>
  40102e:       83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)            # compare number0 and 14
  401033:       76 05                   jbe    40103a <phase_4+0x2e>     # if <=, goto...
  401035:       e8 00 04 00 00          callq  40143a <explode_bomb>     # else BOOM!
  40103a:       ba 0e 00 00 00          mov    $0xe,%edx
  40103f:       be 00 00 00 00          mov    $0x0,%esi
  401044:       8b 7c 24 08             mov    0x8(%rsp),%edi
  401048:       e8 81 ff ff ff          callq  400fce <func4>
                                        # int r = func4(number0, 0, 14);
  40104d:       85 c0                   test   %eax,%eax                 # compare r and 0
  40104f:       75 07                   jne    401058 <phase_4+0x4c>     # if !=, BOOM!
  401051:       83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)            # compare number1 and 0
  401056:       74 05                   je     40105d <phase_4+0x51>     # if ==, OK~
  401058:       e8 dd 03 00 00          callq  40143a <explode_bomb>
  40105d:       48 83 c4 18             add    $0x18,%rsp
  401061:       c3                      retq
```
这里容易确定输入的第二个数字为 number1 = 0，而第一个数字 number0，要满足 func4(number0, 0, 14) 的返回值为0，下来继续分析 `func4`。

```assembly
# int func4(int n, long esi, int edx);  // func4(number0, 0, 14)
# func(arg1, arg2, arg3);
0000000000400fce <func4>:
  400fce:       48 83 ec 08             sub    $0x8,%rsp
  400fd2:       89 d0                   mov    %edx,%eax           # int r = arg3
  400fd4:       29 f0                   sub    %esi,%eax           # r -= arg2
  400fd6:       89 c1                   mov    %eax,%ecx           # unsigned int t = r
  400fd8:       c1 e9 1f                shr    $0x1f,%ecx          # t >>= 31
  400fdb:       01 c8                   add    %ecx,%eax           # r += t
  400fdd:       d1 f8                   sar    %eax                # r >>= 1
  400fdf:       8d 0c 30                lea    (%rax,%rsi,1),%ecx  # t = r + arg2
  400fe2:       39 f9                   cmp    %edi,%ecx           # compare t and arg1
  400fe4:       7e 0c                   jle    400ff2 <func4+0x24> # if <=, goto L1
  400fe6:       8d 51 ff                lea    -0x1(%rcx),%edx     # arg3 = t - 1
  400fe9:       e8 e0 ff ff ff          callq  400fce <func4>      # r = func4(arg1, arg2, arg3)
  400fee:       01 c0                   add    %eax,%eax           # r += r
  400ff0:       eb 15                   jmp    401007 <func4+0x39> # goto END
  # L1:
  400ff2:       b8 00 00 00 00          mov    $0x0,%eax             # r = 0
  400ff7:       39 f9                   cmp    %edi,%ecx             # compare t and arg1
  400ff9:       7d 0c                   jge    401007 <func4+0x39>   # if >=, goto END
  400ffb:       8d 71 01                lea    0x1(%rcx),%esi        # arg2 = t + 1
  400ffe:       e8 cb ff ff ff          callq  400fce <func4>        # r = func4(arg1, arg2, arg3)
  401003:       8d 44 00 01             lea    0x1(%rax,%rax,1),%eax # r = 2 * r + 1
  # END:
  401007:       48 83 c4 08             add    $0x8,%rsp
  40100b:       c3                      retq
```

等价的C语言：

```C
int func4(int arg1, int arg2, int arg3) {
  int r = arg3 - arg2;
  unsigned int t = r >> 31;
  r += t;
  r >>= 1;
  // 😓以上三句其实就是 r /= 2;
  t = r + arg2;
  // 以上五句其实就是 t = (arg3 - arg2) / 2 + arg2，即取 arg3 和 arg2 的中位数。
  if(t > arg1) {
    int r = func4(arg1, arg2, t - 1);
    return r * 2;
  } else if(t < arg1) {
      int r = func4(arg1, t + 1, arg3);
      return 2 * r + 1;
    }
  }
  return 0;
}
```

二分？暂时不清楚这个函数的具体作用，但容易发现，要使 func4(number0, 0, 14)  返回0，可以取 number0 = 7。

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
7 0
So you got that one.  Try this one.
```

## phase_5

```assembly
# void phase_5(char *input)
0000000000401062 <phase_5>:
  401062:       53                      push   %rbx
  401063:       48 83 ec 20             sub    $0x20,%rsp
  401067:       48 89 fb                mov    %rdi,%rbx              # char *p = input
  40106a:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
  401071:       00 00
  401073:       48 89 44 24 18          mov    %rax,0x18(%rsp)
  401078:       31 c0                   xor    %eax,%eax
  40107a:       e8 9c 02 00 00          callq  40131b <string_length> # len = string_length(input)
  40107f:       83 f8 06                cmp    $0x6,%eax
  401082:       74 4e                   je     4010d2 <phase_5+0x70>  # len == 6, goto L1:
  401084:       e8 b1 03 00 00          callq  40143a <explode_bomb>
  401089:       eb 47                   jmp    4010d2 <phase_5+0x70>
  # L2:
  40108b:       0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx     # char c0 = p[i]
  40108f:       88 0c 24                mov    %cl,(%rsp)             # store c0 at %rsp
  401092:       48 8b 14 24             mov    (%rsp),%rdx            # c1 = c0
  401096:       83 e2 0f                and    $0xf,%edx              # c1 &= 0xf
  401099:       0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx    # c3 = *(0x4024b0 + c1)
                                        # 查看 0x4024b0 位置，为字符数组 "maduiersnfotvbyl"
  4010a0:       88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)  # store c3 at %rsp + i + 16
  4010a4:       48 83 c0 01             add    $0x1,%rax              # ++i
  4010a8:       48 83 f8 06             cmp    $0x6,%rax              # compare i:6
  4010ac:       75 dd                   jne    40108b <phase_5+0x29>  # if !=, goto L2
  4010ae:       c6 44 24 16 00          movb   $0x0,0x16(%rsp)        # set 0 at %rsp + 22
  4010b3:       be 5e 24 40 00          mov    $0x40245e,%esi
                                        # 查看 0x40245e 位置，为字符串 "flyers"
  4010b8:       48 8d 7c 24 10          lea    0x10(%rsp),%rdi
  4010bd:       e8 76 02 00 00          callq  401338 <strings_not_equal>
  4010c2:       85 c0                   test   %eax,%eax
  4010c4:       74 13                   je     4010d9 <phase_5+0x77>
  4010c6:       e8 6f 03 00 00          callq  40143a <explode_bomb>
  4010cb:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)        # do nothing 😅
  4010d0:       eb 07                   jmp    4010d9 <phase_5+0x77>
  # L1:
  4010d2:       b8 00 00 00 00          mov    $0x0,%eax               # r = 0
  4010d7:       eb b2                   jmp    40108b <phase_5+0x29>   # goto L2
  4010d9:       48 8b 44 24 18          mov    0x18(%rsp),%rax
  4010de:       64 48 33 04 25 28 00    xor    %fs:0x28,%rax
  4010e5:       00 00
  4010e7:       74 05                   je     4010ee <phase_5+0x8c>
  4010e9:       e8 42 fa ff ff          callq  400b30 <__stack_chk_fail@plt>
  4010ee:       48 83 c4 20             add    $0x20,%rsp
  4010f2:       5b                      pop    %rbx
  4010f3:       c3                      retq
```

对应C语言代码如下：

```c
void phase_5(char *input) {
  const char *source = "maduiersnfotvbyl";
  int len = string_length(input);
  char buffer[7];
  if(len != 6) {
    explode_bomb();
  } else {
    for(int i = 0; i < len; ++i) {
      char index = input[i] & 0xf;
      buffer[i] = source[index];
    }
    buffer[6] = '\0';
    if(strings_not_equal(buffer, "flyers")) {
      explode_bomb();
    }
  }
}
```

要从"maduiersnfotvbyl"中得到"flyers"，可以取下标`9 15 14 5 6 7`，对应十六进制分别为 `0x9 0xf 0xe 0x5 0x6 0x7`，该输入由`input`字符串中每个字符的低8位给出。使用`man ascii` 查看 ASCII 表，对照后可知可以输入 `ionefg`。

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
7 0
So you got that one.  Try this one.
ionefg
Good work!  On to the next...
```



## Phase_6

看起来好长，各种寄存器乱飞，还被各种被打乱，根据各个跳转，分成几部分看。

```assembly
00000000004010f4 <phase_6>:
  4010f4:       41 56                   push   %r14
  4010f6:       41 55                   push   %r13
  4010f8:       41 54                   push   %r12
  4010fa:       55                      push   %rbp
  4010fb:       53                      push   %rbx
  4010fc:       48 83 ec 50             sub    $0x50,%rsp
                                        # int numbers[6]
  401100:       49 89 e5                mov    %rsp,%r13                # r13 = numbers
  401103:       48 89 e6                mov    %rsp,%rsi                # pass numbers
  401106:       e8 51 03 00 00          callq  40145c <read_six_numbers>
                                        # read_six_numbers(input, numbers);
```
开头类似`phase_2`，读取6个数字到 `int numbers[6]` 中，且可以推断 `int numbers[6]` 所在范围为 `%esp ~ %esp + 24`。

```assembly
  40110b:       49 89 e6                mov    %rsp,%r14                # r14 = numbers
  40110e:       41 bc 00 00 00 00       mov    $0x0,%r12d               # r12d = 0
  
  # L5:
  401114:       4c 89 ed                mov    %r13,%rbp                # rbp = r13
  401117:       41 8b 45 00             mov    0x0(%r13),%eax           # get *r13
  40111b:       83 e8 01                sub    $0x1,%eax                # get *r13 - 1
  40111e:       83 f8 05                cmp    $0x5,%eax                # compare *r13 - 1:5
  401121:       76 05                   jbe    401128 <phase_6+0x34>    # if <=, goto L1:
                                        # so *r13 - 1 <= 5
  401123:       e8 12 03 00 00          callq  40143a <explode_bomb>
  # L1:
  401128:       41 83 c4 01             add    $0x1,%r12d            # r12d++
  40112c:       41 83 fc 06             cmp    $0x6,%r12d            # compare r12d:6
  401130:       74 21                   je     401153 <phase_6+0x5f> # if ==, goto L2
  401132:       44 89 e3                mov    %r12d,%ebx            # ebx = r12d
  # L4:
  401135:       48 63 c3                movslq %ebx,%rax             # long rax = ebx
  401138:       8b 04 84                mov    (%rsp,%rax,4),%eax    # get numbers[rax]
  40113b:       39 45 00                cmp    %eax,0x0(%rbp)
                                        # compare number[rax]:number[0]
  40113e:       75 05                   jne    401145 <phase_6+0x51> # if !=, goto L3:
  401140:       e8 f5 02 00 00          callq  40143a <explode_bomb>
  # L3:
  401145:       83 c3 01                add    $0x1,%ebx             # ebx++
  401148:       83 fb 05                cmp    $0x5,%ebx             # compare ebx:5
  40114b:       7e e8                   jle    401135 <phase_6+0x41> # if <=, goto L4
  40114d:       49 83 c5 04             add    $0x4,%r13             # r13 += 4
  401151:       eb c1                   jmp    401114 <phase_6+0x20> # goto L5
```

对应的C语言为：

```c
for(int i = 0; i < 6; ++i) {
  if(numbers[i] - 1 > 5) {
    explode_bomb();
  }
  for(int j = i + 1; j <= 5; ++j) {
    if(numbers[i] == numbers[j]) {
      explode_bomb();
    }
  }
}
```

由此推知输入的六个数各不相同，且范围为[1,6]。

注意以上`%r14`被赋值为`%rsp` 后未改变。

```assembly
  # L2:
  401153:       48 8d 74 24 18          lea    0x18(%rsp),%rsi      # get numbers + 6
  401158:       4c 89 f0                mov    %r14,%rax            # int *rax = numbers
  40115b:       b9 07 00 00 00          mov    $0x7,%ecx            # ecx = 7
  # L6:
  401160:       89 ca                   mov    %ecx,%edx             # edx = ecx
  401162:       2b 10                   sub    (%rax),%edx           # edx -= *rax
  401164:       89 10                   mov    %edx,(%rax)           # *rax = edx
  
  401166:       48 83 c0 04             add    $0x4,%rax             # rax += 1
  40116a:       48 39 f0                cmp    %rsi,%rax             # compare rax:numbers +6
  40116d:       75 f1                   jne    401160 <phase_6+0x6c> # if !=, goto L6
```
对应的C语言为：

```c
for(int i = 0; i != 6; ++i) {
  numbers[i] = 7 - numbers[i];
}
```

以上代码对输入的数字进行了逆序。

下来按顺序跟踪代码

```assembly
  40116f:       be 00 00 00 00          mov    $0x0,%esi             # %esi = 0
  401174:       eb 21                   jmp    401197 <phase_6+0xa3> # goto L7
  # L8:
  401176:       48 8b 52 08             mov    0x8(%rdx),%rdx        # ??? 开始尚不能判断是什么
  40117a:       83 c0 01                add    $0x1,%eax             # ++eax
  40117d:       39 c8                   cmp    %ecx,%eax             # compare %eax:%ecx
  40117f:       75 f5                   jne    401176 <phase_6+0x82> # if !=, goto L8
                                        # 此处结合观察 0x6032d0 的内容，可以发现是个链表，
                                        # 不妨记为 head，可推断 ??? 处 %rdx + 0x8 应该是 next 指针。
  401181:       eb 05                   jmp    401188 <phase_6+0x94> # goto L9
  # L11:
  401183:       ba d0 32 60 00          mov    $0x6032d0,%edx        # edx = 0x6032d0
  # L9:
  401188:       48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2)
  40118d:       48 83 c6 04             add    $0x4,%rsi
  401191:       48 83 fe 18             cmp    $0x18,%rsi
  401195:       74 14                   je     4011ab <phase_6+0xb7> # if ==, goto L10
                                        # 从以上四句可推断 %rsp + 0x20 处保存着一个指针数组，
                                        # 元素大小为8字节，不妨记为 Node* nodes[6];
                                        # 地址范围为 %esp + 0x20 ~ %esp + 0x50
  # L7:
  401197:       8b 0c 34                mov    (%rsp,%rsi,1),%ecx    # %ecx = *(numbers + %rsi)
  40119a:       83 f9 01                cmp    $0x1,%ecx             # compare %ecx:1
  40119d:       7e e4                   jle    401183 <phase_6+0x8f> # if <=, goto L11
  40119f:       b8 01 00 00 00          mov    $0x1,%eax             # %eax = 1
  4011a4:       ba d0 32 60 00          mov    $0x6032d0,%edx        # edx = 0x6032d0
                                        # 0x6032d0 地址信息见下
  4011a9:       eb cb                   jmp    401176 <phase_6+0x82> # goto L8
```
这里发现个地址`0x6032d0`，使用`objdump -t ./bomb` 打印出各段后可发现位于 `.data section`，使用`objdump -s -j .data ./bomb ` 显示该段内容：

```
./bomb:     file format elf64-x86-64

Contents of section .data:

 6032d0 4c010000 01000000 e0326000 00000000  L........2`.....
 6032e0 a8000000 02000000 f0326000 00000000  .........2`.....
 6032f0 9c030000 03000000 00336000 00000000  .........3`.....
 603300 b3020000 04000000 10336000 00000000  .........3`.....
 603310 dd010000 05000000 20336000 00000000  ........ 3`.....
 603320 bb010000 06000000 00000000 00000000  ................
```

对应C语言代码如下：

```c
// 结构体信息
typedef struct {
  int value;
  int n;
  Node *next;
} Node;
Node *head = 0x6032d0;

// 汇编对应代码
Node *nodes[6];
for(int i = 0; i != 6; ++i) {
  Node *p = head;
  for(int j = 1; j < numbers[i]; ++j) {
    p = p->next;
  }
  nodes[i] = p;
}
```
以上的代码根据输入的数字将对应的地址存入nodes数组中。

```assembly
  # L10:
  4011ab:       48 8b 5c 24 20          mov    0x20(%rsp),%rbx     # rbx = nodes[0]
  4011b0:       48 8d 44 24 28          lea    0x28(%rsp),%rax     # rax = &nodes[1]
  4011b5:       48 8d 74 24 50          lea    0x50(%rsp),%rsi     # rsi = &nodes[6]
  4011ba:       48 89 d9                mov    %rbx,%rcx           # rcx = rbx
  # L13:
  4011bd:       48 8b 10                mov    (%rax),%rdx         # rdx = *rax
  4011c0:       48 89 51 08             mov    %rdx,0x8(%rcx)
                                        # *(long*)(rcx + 8) = rdx
  4011c4:       48 83 c0 08             add    $0x8,%rax
  4011c8:       48 39 f0                cmp    %rsi,%rax
  4011cb:       74 05                   je     4011d2 <phase_6+0xde> # if ==, goto L12
  4011cd:       48 89 d1                mov    %rdx,%rcx
  4011d0:       eb eb                   jmp    4011bd <phase_6+0xc9> # goto L13
  # L12:
  4011d2:       48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)        # nodes[5]->next = 0
  4011d9:       00                                                   # do nothing ???
```

```c
for(int i = 1; i != 6; ++i) {
  nodes[i - 1]->next = nodes[i];
}
nodes[5]->next = NULL;
```

以上代码对链表的顺序进行了重排，至此总体上实现了根据输入的数字逆序重排了链表。

循环之后`%rdx`为`nodes[5]`，`%rbx`为`nodes[0]`。

唔，总算快结束了~

```assembly
  4011da:       bd 05 00 00 00          mov    $0x5,%ebp             # %ebp = 5
  # L15
  4011df:       48 8b 43 08             mov    0x8(%rbx),%rax        # %rax = *(%rbx + 8)
  4011e3:       8b 00                   mov    (%rax),%eax           # %eax = *(%rax)
  4011e5:       39 03                   cmp    %eax,(%rbx)           # compare *%rbx:%eax
  4011e7:       7d 05                   jge    4011ee <phase_6+0xfa> # if >=, goto L14
  4011e9:       e8 4c 02 00 00          callq  40143a <explode_bomb>
  # L14:
  4011ee:       48 8b 5b 08             mov    0x8(%rbx),%rbx        # 
  4011f2:       83 ed 01                sub    $0x1,%ebp             # --%ebp
  4011f5:       75 e8                   jne    4011df <phase_6+0xeb> # if !=, goto L15
```
```c
long *p = long_array[0];
Node *head = nodes[0];
for(int i = 5; i != 1; --i) {
  Node *next = head->next;
  if(head->value >= next->value) {
    explode_bomb();
  }
  head = next;
}
```

以上代码对重排后的链表进行检查，要求链表结点的`value`值严格单调递增，而原来结点的值按顺序依次为`0x14c` `0xa8` `0x39c` `0x2b3` `0x1dd` `0x1bb`，正确的顺序应该为 `3 4 5 6 1 2`，由此可以推断应该输入`4 3 2 1 6 5`。

清栈，返回。

```assembly
  4011f7:       48 83 c4 50             add    $0x50,%rsp
  4011fb:       5b                      pop    %rbx
  4011fc:       5d                      pop    %rbp
  4011fd:       41 5c                   pop    %r12
  4011ff:       41 5d                   pop    %r13
  401201:       41 5e                   pop    %r14
  401203:       c3                      retq
```

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
7 0
So you got that one.  Try this one.
ionefg
Good work!  On to the next...
4 3 2 1 6 5
Congratulations! You've defused the bomb!
```

~~成功搞定！~~ 咦？等等，貌似还有个隐藏关？...(*￣０￣)ノ（呼~~~ 干了一天好累，先留坑明天继续，还是睡觉要紧 >_<

---
*2017-02-11 更新*

## secret_phase

反汇编过程中，可以发现还有`secret_phase`这个函数，然而并没有用到，而且提供的`bomb.c`文件也给了一定的提示，搜索之后发现该函数出现在`phase_defused`中。

```assembly
00000000004015c4 <phase_defused>:
  4015c4:       48 83 ec 78             sub    $0x78,%rsp
  4015c8:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
  4015cf:       00 00
  4015d1:       48 89 44 24 68          mov    %rax,0x68(%rsp)
  4015d6:       31 c0                   xor    %eax,%eax
  4015d8:       83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 <num_input_strings>
  4015df:       75 5e                   jne    40163f <phase_defused+0x7b># if !=, goto END
                # 这里可知只有 num_input_strings 为 6 时才会继续
                # 检查 real_line 后可发现每读入一行，num_input_strings 增 1
  4015e1:       4c 8d 44 24 10          lea    0x10(%rsp),%r8
  4015e6:       48 8d 4c 24 0c          lea    0xc(%rsp),%rcx
  4015eb:       48 8d 54 24 08          lea    0x8(%rsp),%rdx
  4015f0:       be 19 26 40 00          mov    $0x402619,%esi
                                        # "%d %d %s"
  4015f5:       bf 70 38 60 00          mov    $0x603870,%edi
                                        # 这里用到了 GDB，调试时输入 x 0x603870
                                        # 0x603870 <input_strings+240>:   0x00000000
                                        # 又每次输入时最多接受 80 个字符，由此推知这里取第四次输入
  4015fa:       e8 f1 f5 ff ff          callq  400bf0 <__isoc99_sscanf@plt>
  4015ff:       83 f8 03                cmp    $0x3,%eax
  401602:       75 31                   jne    401635 <phase_defused+0x71>
  401604:       be 22 26 40 00          mov    $0x402622,%esi
                                        # "DrEvil"
  401609:       48 8d 7c 24 10          lea    0x10(%rsp),%rdi
  40160e:       e8 25 fd ff ff          callq  401338 <strings_not_equal>
  401613:       85 c0                   test   %eax,%eax
  401615:       75 1e                   jne    401635 <phase_defused+0x71>
                                        # 至此可知输入第四次口令时应该多输入 "DrEvil"
  401617:       bf f8 24 40 00          mov    $0x4024f8,%edi
                                        # "Curses, you've found the secret phase!"
  40161c:       e8 ef f4 ff ff          callq  400b10 <puts@plt>
  401621:       bf 20 25 40 00          mov    $0x402520,%edi
                                        # "But finding it and solving it are quite different..."
  401626:       e8 e5 f4 ff ff          callq  400b10 <puts@plt>
  40162b:       b8 00 00 00 00          mov    $0x0,%eax
  401630:       e8 0d fc ff ff          callq  401242 <secret_phase>
  401635:       bf 58 25 40 00          mov    $0x402558,%edi
                                        # "Congratulations! You've defused the bomb!"
  40163a:       e8 d1 f4 ff ff          callq  400b10 <puts@plt>
  # END:
  40163f:       48 8b 44 24 68          mov    0x68(%rsp),%rax
  401644:       64 48 33 04 25 28 00    xor    %fs:0x28,%rax
  40164b:       00 00
  40164d:       74 05                   je     401654 <phase_defused+0x90>
  40164f:       e8 dc f4 ff ff          callq  400b30 <__stack_chk_fail@plt>
  401654:       48 83 c4 78             add    $0x78,%rsp
  401658:       c3                      retq
```

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
7 0 DrEvil
So you got that one.  Try this one.
ionefg
Good work!  On to the next...
4 3 2 1 6 5
Curses, you've found the secret phase!
But finding it and solving it are quite different...

```

唔，这样就进入了隐藏关卡，继续看`secret_phase`。


```assembly
0000000000401242 <secret_phase>:
  401242:       53                      push   %rbx
  401243:       e8 56 02 00 00          callq  40149e <read_line>
  401248:       ba 0a 00 00 00          mov    $0xa,%edx                    # 10
  40124d:       be 00 00 00 00          mov    $0x0,%esi                    # 0
  401252:       48 89 c7                mov    %rax,%rdi                    # input
  401255:       e8 76 f9 ff ff          callq  400bd0 <strtol@plt>
                                        # int n = strtol(input, 0, 10);
  40125a:       48 89 c3                mov    %rax,%rbx
  40125d:       8d 40 ff                lea    -0x1(%rax),%eax              # n - 1
  401260:       3d e8 03 00 00          cmp    $0x3e8,%eax                  # compare n - 1:1000
  401265:       76 05                   jbe    40126c <secret_phase+0x2a>   # if <=, goto L1
  401267:       e8 ce 01 00 00          callq  40143a <explode_bomb>
                                        # 由此推断输入的整数范围为 [1, 1000]
  # L1:
  40126c:       89 de                   mov    %ebx,%esi
  40126e:       bf f0 30 60 00          mov    $0x6030f0,%edi               # ???
  401273:       e8 8c ff ff ff          callq  401204 <fun7>
  401278:       83 f8 02                cmp    $0x2,%eax
  40127b:       74 05                   je     401282 <secret_phase+0x40>
  40127d:       e8 b8 01 00 00          callq  40143a <explode_bomb>
  # 以上表示需要调用 fun7(0x6030f0, n) 后返回 2，见以下 fun7 接着分析。
  401282:       bf 38 24 40 00          mov    $0x402438,%edi
                                        # "Wow! You've defused the secret stage!"
  401287:       e8 84 f8 ff ff          callq  400b10 <puts@plt>
  40128c:       e8 33 03 00 00          callq  4015c4 <phase_defused>
                                        # 由于 read_line 将使 num_input_strings 增1，
                                        # 进入 phase_defused 后会调到 0x40163f 地址处，结束。
  401291:       5b                      pop    %rbx
  401292:       c3                      retq
```
查看 `.data section` 地址 `6030f0 ` 处，~~看起来又是个链表~~ 应该是棵二叉树😅

```
 6030f0 24000000 00000000 10316000 00000000  $........1`.....
 603100 30316000 00000000 00000000 00000000  01`.............
 603110 08000000 00000000 90316000 00000000  .........1`.....
 603120 50316000 00000000 00000000 00000000  P1`.............
 603130 32000000 00000000 70316000 00000000  2.......p1`.....
 603140 b0316000 00000000 00000000 00000000  .1`.............
 603150 16000000 00000000 70326000 00000000  ........p2`.....
 603160 30326000 00000000 00000000 00000000  02`.............
 603170 2d000000 00000000 d0316000 00000000  -........1`.....
 603180 90326000 00000000 00000000 00000000  .2`.............
 603190 06000000 00000000 f0316000 00000000  .........1`.....
 6031a0 50326000 00000000 00000000 00000000  P2`.............
 6031b0 6b000000 00000000 10326000 00000000  k........2`.....
 6031c0 b0326000 00000000 00000000 00000000  .2`.............
 6031d0 28000000 00000000 00000000 00000000  (...............
 6031e0 00000000 00000000 00000000 00000000  ................
 6031f0 01000000 00000000 00000000 00000000  ................
 603200 00000000 00000000 00000000 00000000  ................
 603210 63000000 00000000 00000000 00000000  c...............
 603220 00000000 00000000 00000000 00000000  ................
 603230 23000000 00000000 00000000 00000000  #...............
 603240 00000000 00000000 00000000 00000000  ................
 603250 07000000 00000000 00000000 00000000  ................
 603260 00000000 00000000 00000000 00000000  ................
 603270 14000000 00000000 00000000 00000000  ................
 603280 00000000 00000000 00000000 00000000  ................
 603290 2f000000 00000000 00000000 00000000  /...............
 6032a0 00000000 00000000 00000000 00000000  ................
 6032b0 e9030000 00000000 00000000 00000000  ................
 6032c0 00000000 00000000 00000000 00000000  ................
 
 大概是：
 @6030f0 0x24
   -> @603110 0x08
     -> @603190 0x06
       -> @6031f0 0x01
       -> @603250 0x07
     -> @603150 0x16
       -> @603270 0x14
       -> @603230 0x23
   -> @603130 0x32
     -> @603170 0x2d
       -> @6031d0 0x28
       -> @603290 0x2f
     -> @6031b0 0x6b
       -> @603210 0x63
       -> @6032b0 0x3e9
```



```assembly
# int fun7(Node *p, int n);
0000000000401204 <fun7>:
  401204:       48 83 ec 08             sub    $0x8,%rsp
  401208:       48 85 ff                test   %rdi,%rdi
  40120b:       74 2b                   je     401238 <fun7+0x34>      # if ==, goto L1
  40120d:       8b 17                   mov    (%rdi),%edx             # int value = p->value;
  40120f:       39 f2                   cmp    %esi,%edx               # compare value:n
  401211:       7e 0d                   jle    401220 <fun7+0x1c>      # if <=, goto L2
  401213:       48 8b 7f 08             mov    0x8(%rdi),%rdi          # p = p->left;
  401217:       e8 e8 ff ff ff          callq  401204 <fun7>           # result = fun7(p, n)
  40121c:       01 c0                   add    %eax,%eax               # return 2 * result
  40121e:       eb 1d                   jmp    40123d <fun7+0x39>      # goto END
  # L2:
  401220:       b8 00 00 00 00          mov    $0x0,%eax               # result 0
  401225:       39 f2                   cmp    %esi,%edx               # compare value:n
  401227:       74 14                   je     40123d <fun7+0x39>      # if ==, goto END
  401229:       48 8b 7f 10             mov    0x10(%rdi),%rdi         # ++p
  40122d:       e8 d2 ff ff ff          callq  401204 <fun7>           # result = fun7(p, n)
  401232:       8d 44 00 01             lea    0x1(%rax,%rax,1),%eax   # result = 2 * result + 1
  401236:       eb 05                   jmp    40123d <fun7+0x39>      # goto END
  # L1：
  401238:       b8 ff ff ff ff          mov    $0xffffffff,%eax        # result =  -1
  # END:
  40123d:       48 83 c4 08             add    $0x8,%rsp
  401241:       c3                      retq
```

对应C语言：

```c
typedef struct {
  long value;
  Tree *left;
  Tree *right;
  char padding[8];
} Tree;
int fun7(Node *p, int n) {
  if(p == NULL) return -1;
  if(p->value > n) {
    return 2 * fun7(p->left, n);
  } else if(p->value == n) {
    return 0;
  } else {
    return 2 * fun7(p->right, n) + 1;
  }
}
```

对二叉查找树进行查找，由返回值`2`可猜测`n`的值为`0x16`即`22`。

```
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Border relations with Canada have never been better.
Phase 1 defused. How about the next one?
1 2 4 8 16 32
That's number 2.  Keep going!
0 207
Halfway there!
7 0 DrEvil
So you got that one.  Try this one.
ionefg
Good work!  On to the next...
4 3 2 1 6 5
Curses, you've found the secret phase!
But finding it and solving it are quite different...
22
Wow! You've defused the secret stage!
Congratulations! You've defused the bomb!
```

DONE！元宵节快乐~（然而又到了睡觉的时候 >_<